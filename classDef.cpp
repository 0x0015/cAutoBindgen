#include "classDef.hpp"
#include <iostream>
#include <algorithm>
#include <unordered_set>

void classDef::print() const{
		std::cout<<"class size: "<<size<<std::endl;
		for(const auto& member : members){
			std::cout<<"\tmember: "<<member.name<<"(";
			for(unsigned int i=0;i<member.args.size();i++){
				std::cout<<member.args[i].first;
				if(i+1 < member.args.size())
					std::cout<<", ";
			}
			std::cout<<")"<<std::endl;
		}
}

void classDef::fixConstructDesconstructorTypes(){
	for(auto& func : members){
		if(func.name == name)
			func.retType = name + "_c*";
		if(func.name[0] == '~')
			func.retType = "void";
		for(unsigned int i=0;i<func.args.size();i++){
			if(func.args[i].second.empty())
				func.args[i].second = "arg_" + std::to_string(i);
		}
	}
}

std::string toAllCaps(const std::string& str){
	std::string output = str;
	for(unsigned int i=0;i<output.size();i++){
		output[i] = std::toupper(output[i]);
	}
	return output;
}

std::string getCFuncName(const std::string& cppName, const std::string& className, const std::unordered_set<std::string>& definedFuncs){
	std::string funcName;
	if(cppName == className){
		//constructor
		funcName = className + "_construct";
	}else if(cppName[0] == '~'){
		funcName = className + "_destroy";
	}else{
		funcName = className + "_" + cppName;
	}
	if(definedFuncs.contains(funcName)){
		unsigned int funcDefNum = 1;
		while(definedFuncs.contains(funcName + std::to_string(funcDefNum)))
			funcDefNum++;
		funcName += std::to_string(funcDefNum);
	}
	return funcName;
}

std::string classDef::genCHeader() const{
	std::string CHeader;

	CHeader += "#ifndef " + toAllCaps(name) + "_AUTOGENERATED_H\n#define " + toAllCaps(name) + "_AUTOGENERATED_H\n";	
	CHeader += '\n';

	CHeader += "#ifdef __cplusplus\nextern \"C\"{\n#endif\n";
	CHeader += '\n';

	CHeader += "#include <stdbool.h>\n\n";//for C++ expects this to be built in

	CHeader += "typedef struct " + name + "_c_structdef{} " + name + "_c;\n";
	CHeader += '\n';

	std::unordered_set<std::string> definedFuncs;//c++ allows overloading, c doesn't
	for(const auto& func : members){
		std::string funcName = getCFuncName(func.name, name, definedFuncs);
		definedFuncs.insert(funcName);

		if(func.name != name){
			CHeader += func.retType + " " + funcName + "(" + name + "_c* self";
			if(!func.args.empty())
				CHeader += ", ";
		}else{
			//special case for constructors
			CHeader += func.retType + " " + funcName + "(";
		}
		for(unsigned int i=0;i<func.args.size();i++){
			CHeader += func.args[i].first + " " + func.args[i].second;
			if(i+1 < func.args.size())
				CHeader += ", ";
		}
		CHeader += ");\n";
	}
	CHeader += '\n';

	CHeader += "#ifdef __cplusplus\n}\n#endif\n";
	CHeader += '\n';

	CHeader += "#endif";

	return CHeader;
}

std::string classDef::genCppSource(const std::string& CHeaderName, const std::vector<std::string>& headersToInclude) const{
	std::string CppSource;

	CppSource += "#include \"" + CHeaderName + "\"\n";
	for(const auto& header : headersToInclude){
		CppSource += "#include \"" + header + "\"\n";
	}
	CppSource += '\n';

	std::unordered_set<std::string> definedFuncs;//c++ allows overloading, c doesn't
	for(const auto& func : members){
		std::string funcName = getCFuncName(func.name, name, definedFuncs);
		definedFuncs.insert(funcName);

		if(func.name != name){
			CppSource += func.retType + " " + funcName + "(" + name + "_c* self";//mest be distinct from this
			if(!func.args.empty())
				CppSource += ", ";
		}else{
			//special case for constructors
			CppSource += func.retType + " " + funcName + "(";
		}
		for(unsigned int i=0;i<func.args.size();i++){
			CppSource += func.args[i].first + " " + func.args[i].second;
			if(i+1 < func.args.size())
				CppSource += ", ";
		}
		CppSource += "){\n";
		//special cases for constructor and deconstructor
		if(func.name == name){
			CppSource += "\treturn (" + name + "_c*) new " + name + "(";
			for(unsigned int i=0;i<func.args.size();i++){
				CppSource += func.args[i].second;
				if(i+1 < func.args.size())
					CppSource += ", ";
			}
			CppSource += ");\n";
		}else if(func.name[0] == '~'){
			CppSource += "\tdelete (" + name + "*)self;\n";
		}else{
			CppSource += '\t';
			if(func.retType != "void")
				CppSource += "return ";
			CppSource += "((" + name + "*)self)->" + func.name + "(";
			for(unsigned int i=0;i<func.args.size();i++){
				CppSource += func.args[i].second;
				if(i+1 < func.args.size())
					CppSource += ", ";
			}
			CppSource += ");\n";
		}
		CppSource += "}\n\n";
	}

	return CppSource;
}

