#include "cppWorkspace.hpp"
#include <iostream>
#include <algorithm>
#include <unordered_set>
#include "json.hpp"

void cppWorkspace::print() const{
	for(const auto& cl : classes){
		std::cout<<"class: "<<cl.name<<std::endl;
		std::cout<<"class size: "<<cl.size<<std::endl;
		std::cout<<"class parents: ";
		for(unsigned int i=0;i<cl.memberOfList.size();i++){
			std::cout<<cl.memberOfList[i];
			if(i+1 < cl.memberOfList.size())
				std::cout<<"::";
		}
		std::cout<<std::endl;
	}
	for(const auto& en : enums){
		std::cout<<"enum: "<<en.name<<std::endl;
		std::cout<<"enum size: "<<en.size<<std::endl;
		for(const auto& value : en.values){
			std::cout<<'\t'<<value.first;
			if(value.second)
				std::cout<<" = "<<*value.second;
			std::cout<<std::endl;
		}
		std::cout<<"enum parents: ";
		for(unsigned int i=0;i<en.memberOfList.size();i++){
			std::cout<<en.memberOfList[i];
			if(i+1 < en.memberOfList.size())
				std::cout<<"::";
		}
		std::cout<<std::endl;
	}
	for(const auto& func : functions){
		std::cout<<"function: "<<func.name<<std::endl;
		std::cout<<"\t(";
		for(unsigned int i=0;i<func.args.size();i++){
			std::cout<<func.args[i].first;
			if(func.args[i].second)
				std::cout<<' '<<*func.args[i].second;
			if(i+1 < func.args.size()){
				std::cout<<", ";
			}
		}
		std::cout<<")->"<<func.rtype<<std::endl;
		std::cout<<"function parents: ";
		for(unsigned int i=0;i<func.memberOfList.size();i++){
			std::cout<<func.memberOfList[i];
			if(i+1 < func.memberOfList.size())
				std::cout<<"::";
		}
		std::cout<<std::endl;
	}
}

void cppWorkspace::fixConstructDesconstructorTypes(){
	for(auto& func : functions){
		if(!func.memberOfList.empty()){
			if(func.name == func.memberOfList.back())
				func.rtype = func.name;
			if(func.name[0] == '~')
				func.rtype = "void";
		}
		for(unsigned int i=0;i<func.args.size();i++){
			if(!func.args[i].second)
				func.args[i].second = "arg_" + std::to_string(i);
		}
	}
}

std::string toAllCaps(const std::string& str){
	std::string output = str;
	for(unsigned int i=0;i<output.size();i++){
		output[i] = std::toupper(output[i]);
	}
	return output;
}

std::string getCFuncName(const std::string& cppName, const std::string& className, const std::unordered_set<std::string>& definedFuncs){
	std::string funcName;
	if(cppName == className){
		//constructor
		funcName = className + "_construct";
	}else if(cppName[0] == '~'){
		funcName = className + "_destroy";
	}else{
		funcName = className + "_" + cppName;
	}
	if(definedFuncs.contains(funcName)){
		unsigned int funcDefNum = 1;
		while(definedFuncs.contains(funcName + std::to_string(funcDefNum)))
			funcDefNum++;
		funcName += std::to_string(funcDefNum);
	}
	return funcName;
}

std::string cppWorkspace::genCHeader() const{
	std::string CHeader;

	CHeader += "#ifndef " + toAllCaps(name) + "_AUTOGENERATED_H\n#define " + toAllCaps(name) + "_AUTOGENERATED_H\n";	
	CHeader += '\n';

	CHeader += "#ifdef __cplusplus\nextern \"C\"{\n#endif\n";
	CHeader += '\n';

	CHeader += "#include <stdbool.h>\n\n";//for C++ expects this to be built in

	for(const auto& cl : classes){
		CHeader += "typedef struct " + cl.name + "_c_structdef{} " + cl.name + "_c;\n";
	}
	CHeader += '\n';

	std::unordered_set<std::string> definedFuncs;//c++ allows overloading, c doesn't
	for(const auto& func : functions){
		std::string funcName = getCFuncName(func.name, name, definedFuncs);
		definedFuncs.insert(funcName);

		if(func.name != name){
			CHeader += func.rtype + " " + funcName + "(" + name + "_c* self";
			if(!func.args.empty())
				CHeader += ", ";
		}else{
			//special case for constructors
			CHeader += func.rtype + " " + funcName + "(";
		}
		for(unsigned int i=0;i<func.args.size();i++){
			CHeader += func.args[i].first + " " + *func.args[i].second;
			if(i+1 < func.args.size())
				CHeader += ", ";
		}
		CHeader += ");\n";
	}
	CHeader += '\n';

	CHeader += "#ifdef __cplusplus\n}\n#endif\n";
	CHeader += '\n';

	CHeader += "#endif";

	return CHeader;
}

std::string cppWorkspace::genCppSource(const std::string& CHeaderName, const std::vector<std::string>& headersToInclude) const{
	std::string CppSource;

	CppSource += "#include \"" + CHeaderName + "\"\n";
	for(const auto& header : headersToInclude){
		CppSource += "#include \"" + header + "\"\n";
	}
	CppSource += '\n';

	std::unordered_set<std::string> definedFuncs;//c++ allows overloading, c doesn't
	for(const auto& func : functions){
		std::string funcName = getCFuncName(func.name, name, definedFuncs);
		definedFuncs.insert(funcName);

		if(func.name != name){
			CppSource += func.rtype + " " + funcName + "(" + name + "_c* self";//mest be distinct from this
			if(!func.args.empty())
				CppSource += ", ";
		}else{
			//special case for constructors
			CppSource += func.rtype + " " + funcName + "(";
		}
		for(unsigned int i=0;i<func.args.size();i++){
			CppSource += func.args[i].first + " " + *func.args[i].second;
			if(i+1 < func.args.size())
				CppSource += ", ";
		}
		CppSource += "){\n";
		//special cases for constructor and deconstructor
		if(func.name == name){
			CppSource += "\treturn (" + name + "_c*) new " + name + "(";
			for(unsigned int i=0;i<func.args.size();i++){
				CppSource += *func.args[i].second;
				if(i+1 < func.args.size())
					CppSource += ", ";
			}
			CppSource += ");\n";
		}else if(func.name[0] == '~'){
			CppSource += "\tdelete (" + name + "*)self;\n";
		}else{
			CppSource += '\t';
			if(func.rtype != "void")
				CppSource += "return ";
			CppSource += "((" + name + "*)self)->" + func.name + "(";
			for(unsigned int i=0;i<func.args.size();i++){
				CppSource += *func.args[i].second;
				if(i+1 < func.args.size())
					CppSource += ", ";
			}
			CppSource += ");\n";
		}
		CppSource += "}\n\n";
	}

	return CppSource;
}

std::string cppWorkspace::genJsonDetail() const{
	nlohmann::json j;

	

	return j.dump(1, '\t');
}

